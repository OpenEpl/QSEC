.程序集 RTF文档, <对象>
.程序集变量 颜色表, 整数型, , "0"
.程序集变量 字体表, 文本型, , "0"
.程序集变量 文本代码, 快速文本连接
.程序集变量 颜色表代码, 快速文本连接
.程序集变量 字体表代码, 快速文本连接
.程序集变量 最后一个为不完整控制字符, 逻辑型, , , 未插入任何字符时为 真，因为 文本代码头 的最后一个为 未结束的控制字符

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用

RTF文档.清空 ()
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用


.子程序 清空, , 公开

文本代码.清空 ()
颜色表代码.清空 ()
字体表代码.清空 ()
清除数组 (颜色表)
清除数组 (字体表)
最后一个为不完整控制字符 = 真

加入成员 (字体表, “宋体”)
增加字体表代码 (“{\f0\fnil\fcharset1\'cb\'ce\'cc\'e5;}”)
.子程序 增加代码
.参数 text, 文本型

文本代码.添加 (text)
.子程序 增加颜色表代码
.参数 t, 文本型

颜色表代码.添加 (t)
.子程序 增加字体表代码
.参数 t, 文本型

字体表代码.添加 (t)
.子程序 取颜色ID, 整数型
.参数 颜色, 整数型
.局部变量 i, 整数型

.计次循环首 (取数组下标 (颜色表, ), i)
    .如果真 (颜色表[i] == 颜色)
        返回 (i)
    .如果真结束
    
.计次循环尾 ()
加入成员 (颜色表, 颜色)
增加颜色表代码 (“\red”)
增加颜色表代码 (到文本 (取红色值 (颜色)))
增加颜色表代码 (“\green”)
增加颜色表代码 (到文本 (取绿色值 (颜色)))
增加颜色表代码 (“\blue”)
增加颜色表代码 (到文本 (取蓝色值 (颜色)))
增加颜色表代码 (“;”)
返回 (取数组下标 (颜色表, ))
.子程序 取字体ID, 整数型
.参数 字体名称, 文本型
.局部变量 i, 整数型
.局部变量 id, 整数型

.计次循环首 (取数组下标 (字体表, ), i)
    .如果真 (字体表[i] == 字体名称)
        返回 (i)
    .如果真结束
    
.计次循环尾 ()
id = 取数组下标 (字体表, )
加入成员 (字体表, 字体名称)
增加字体表代码 (“{\f”)
增加字体表代码 (到文本 (id))
增加字体表代码 (“\fnil\fcharset1”)
添加转义后文本 (字体表代码, 字体名称, 真)
增加字体表代码 (“;}”)
返回 (id)
.子程序 添加转义后文本
.参数 参数_b, 快速文本连接
.参数 参数_text, 文本型
.参数 参数_最后一个为不完整控制字符, 逻辑型, 参考
.局部变量 i, 整数型
.局部变量 len, 整数型
.局部变量 bytes, 字节集

i = 1
bytes = 到字节集 (参数_text)
len = 取字节集长度 (bytes)
.判断循环首 (i <= len)
    .如果 (bytes[i] > 127 && i + 1 <= len)
        .如果 (bytes[i] < 16)
            参数_b.添加 (“\'0”)
            参数_b.添加 (取十六进制文本 (bytes[i]))
        .否则
            参数_b.添加 (“\'”)
            参数_b.添加 (取十六进制文本 (bytes[i]))
        .如果结束
        .如果 (bytes[i + 1] < 16)
            参数_b.添加 (“\'0”)
            参数_b.添加 (取十六进制文本 (bytes[i + 1]))
        .否则
            参数_b.添加 (“\'”)
            参数_b.添加 (取十六进制文本 (bytes[i + 1]))
        .如果结束
        参数_最后一个为不完整控制字符 = 假
        i = i + 2
    .否则
        .判断开始 (bytes[i] == 123 || bytes[i] == 125 || bytes[i] == 92)
            参数_b.添加 (“\”)
            参数_b.添加 (字符 (bytes[i]))
            参数_最后一个为不完整控制字符 = 假
        .判断 (bytes[i] == #Tab键)
            参数_b.添加 (“\tab”)
            参数_最后一个为不完整控制字符 = 真
        .判断 (bytes[i] == 13)  ' 回车符
            参数_b.添加 (“\par”)
            .如果真 (i + 1 <= len)
                .如果真 (bytes[i + 1] == 10)  ' 换行符
                    i = i + 1
                .如果真结束
                
            .如果真结束
            参数_最后一个为不完整控制字符 = 真
        .判断 (bytes[i] == 10)  ' 换行符
            参数_b.添加 (“\par”)
            参数_最后一个为不完整控制字符 = 真
        .默认
            .如果真 (参数_最后一个为不完整控制字符)
                .如果真 (bytes[i] >= 65 && bytes[i] <= 90 || bytes[i] >= 48 && bytes[i] <= 57 || bytes[i] >= 97 && bytes[i] <= 122 || bytes[i] == 45 || bytes[i] == 32)  ' 大写字母、小写字母、数字、-、空格
                    参数_b.添加 (“ ”)
                .如果真结束
                
            .如果真结束
            参数_b.添加 (字符 (bytes[i]))
            参数_最后一个为不完整控制字符 = 假
        .判断结束
        i = i + 1
    .如果结束
    
.判断循环尾 ()
.子程序 默认颜色, , 公开

增加代码 (“\cf0”)
最后一个为不完整控制字符 = 真
.子程序 颜色, , 公开
.参数 颜色值, 整数型

增加代码 (“\cf”)
增加代码 (到文本 (取颜色ID (颜色值)))
最后一个为不完整控制字符 = 真
.子程序 字体, , 公开
.参数 字体名称, 文本型, , 默认字体为 宋体

增加代码 (“\f”)
增加代码 (到文本 (取字体ID (字体名称)))
最后一个为不完整控制字符 = 真
.子程序 突出显示, , 公开, 又称 置背景色
.参数 颜色值, 整数型

增加代码 (“\highlight”)
增加代码 (到文本 (取颜色ID (颜色值)))
最后一个为不完整控制字符 = 真
.子程序 取消突出显示, , 公开, 又称 取消背景色

增加代码 (“\highlight0”)
.子程序 文本, , 公开
.参数 text, 文本型

添加转义后文本 (文本代码, text, 最后一个为不完整控制字符)
.子程序 字号, , 公开
.参数 pt, 整数型

增加代码 (“\fs”)
增加代码 (到文本 (pt * 2))
最后一个为不完整控制字符 = 真
.子程序 下划线, , 公开
.参数 启用, 逻辑型

.如果 (启用)
    增加代码 (“\ul”)
.否则
    增加代码 (“\ulnone”)
.如果结束
最后一个为不完整控制字符 = 真
.子程序 删除线, , 公开
.参数 启用, 逻辑型

.如果 (启用)
    增加代码 (“\strike”)
.否则
    增加代码 (“\strike0”)
.如果结束
最后一个为不完整控制字符 = 真
.子程序 粗体, , 公开
.参数 启用, 逻辑型

.如果 (启用)
    增加代码 (“\b”)
.否则
    增加代码 (“\b0”)
.如果结束
最后一个为不完整控制字符 = 真
.子程序 斜体, , 公开
.参数 启用, 逻辑型

.如果 (启用)
    增加代码 (“\i”)
.否则
    增加代码 (“\i0”)
.如果结束
最后一个为不完整控制字符 = 真
.子程序 开始组, , 公开, 开始组后，在该组中定义的格式，将仅应用于当前组

增加代码 (“{”)
最后一个为不完整控制字符 = 假
.子程序 结束组, , 公开

增加代码 (“}”)
最后一个为不完整控制字符 = 假
.子程序 开始超链接, , 公开, 会自动开始新的一组，注意，易语言自带的超级编辑框不能生成可点击的超链接，也无法识别超链接文本中的换行！
.参数 URL, 文本型

增加代码 (“{\field{\*\fldinst{HYPERLINK ”)
增加代码 (#引号)
增加代码 (URL)
增加代码 (#引号)
增加代码 (“}}{\fldrslt{”)
.子程序 结束超链接, , 公开

增加代码 (“}}}”)
.子程序 段落, , 公开

增加代码 (“\pard”)
.子程序 居中对齐, , 公开, 同一个段落应只设置一次对齐方式

增加代码 (“\qc”)
.子程序 两端对齐, , 公开, 同一个段落应只设置一次对齐方式

增加代码 (“\qj”)
.子程序 左对齐, , 公开, 同一个段落应只设置一次对齐方式

增加代码 (“\ql”)
.子程序 右对齐, , 公开, 同一个段落应只设置一次对齐方式

增加代码 (“\qr”)
.子程序 分散对齐, , 公开, 同一个段落应只设置一次对齐方式

增加代码 (“\qd”)
.子程序 取完整代码, 文本型, 公开
.局部变量 完整代码, 文本型
.局部变量 地址, 整数型
.局部变量
.局部变量 完整代码头, 文本型
.局部变量 完整代码尾, 文本型
.局部变量
.局部变量 颜色表头, 文本型
.局部变量 颜色表尾, 文本型
.局部变量
.局部变量 字体表头, 文本型
.局部变量 字体表尾, 文本型
.局部变量
.局部变量 文档属性, 文本型
.局部变量
.局部变量 长度, 整数型
.局部变量 长度_完整代码头, 整数型
.局部变量 长度_文档属性, 整数型
.局部变量 长度_完整代码尾, 整数型
.局部变量 长度_颜色表头, 整数型
.局部变量 长度_颜色表尾, 整数型
.局部变量 长度_文本代码, 整数型
.局部变量 长度_颜色表代码, 整数型
.局部变量 长度_字体表头, 整数型
.局部变量 长度_字体表尾, 整数型
.局部变量 长度_字体表代码, 整数型

完整代码头 = “{\rtf1\ansi\ansicpg” + 到文本 (GetACP ()) + “\deff0\deflang1033\deflangfe2052{\fonttbl{\f0\fnil\fcharset1 \'cb\'ce\'cc\'e5;}}”
完整代码尾 = “}”
颜色表头 = “{\colortbl ;”
颜色表尾 = “}”
文档属性 = “\viewkind4\uc1\pard\fs18”
字体表头 = “{\fonttbl”
字体表尾 = “}”

长度_完整代码头 = 取文本长度 (完整代码头)
长度_文档属性 = 取文本长度 (文档属性)
长度_完整代码尾 = 取文本长度 (完整代码尾)
长度_颜色表头 = 取文本长度 (颜色表头)
长度_颜色表尾 = 取文本长度 (颜色表尾)
长度_文本代码 = 文本代码.取内容长度 ()
长度_颜色表代码 = 颜色表代码.取内容长度 ()
长度_字体表代码 = 字体表代码.取内容长度 ()
长度_字体表头 = 取文本长度 (字体表头)
长度_字体表尾 = 取文本长度 (字体表尾)

长度 = 长度_颜色表代码
.如果真 (长度 != 0)
    长度 = 长度 + 长度_颜色表头 + 长度_颜色表尾
.如果真结束
长度 = 长度 + 长度_完整代码头 + 长度_文档属性 + 长度_完整代码尾 + 长度_文本代码 + 长度_字体表头 + 长度_字体表尾 + 长度_字体表代码

完整代码 = 取空白文本 (长度)

地址 = 取变量数据地址_文本型 (完整代码)
CopyMemory (地址, 取变量数据地址_文本型 (完整代码头), 长度_完整代码头)
地址 = 地址 + 长度_完整代码头

CopyMemory (地址, 取变量数据地址_文本型 (字体表头), 长度_字体表头)
地址 = 地址 + 长度_字体表头

CopyMemory (地址, 字体表代码.取缓冲区地址 (), 长度_字体表代码)
地址 = 地址 + 长度_字体表代码

CopyMemory (地址, 取变量数据地址_文本型 (字体表尾), 长度_字体表尾)
地址 = 地址 + 长度_字体表尾


.如果真 (颜色表代码.取内容长度 () != 0)
    CopyMemory (地址, 取变量数据地址_文本型 (颜色表头), 长度_颜色表头)
    地址 = 地址 + 长度_颜色表头
    
    CopyMemory (地址, 颜色表代码.取缓冲区地址 (), 长度_颜色表代码)
    地址 = 地址 + 长度_颜色表代码
    
    CopyMemory (地址, 取变量数据地址_文本型 (颜色表尾), 长度_颜色表尾)
    地址 = 地址 + 长度_颜色表尾
.如果真结束

CopyMemory (地址, 取变量数据地址_文本型 (文档属性), 长度_文档属性)
地址 = 地址 + 长度_文档属性

CopyMemory (地址, 文本代码.取缓冲区地址 (), 长度_文本代码)
地址 = 地址 + 长度_文本代码


CopyMemory (地址, 取变量数据地址_文本型 (完整代码尾), 长度_完整代码尾)
地址 = 地址 + 长度_完整代码尾
返回 (完整代码)