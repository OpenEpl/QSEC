.程序集 BaseHashMap

.子程序 底层哈希表_创建, 整数型, 公开, 底层哈希表_初始化(申请内存(#底层哈希表_内存大小))
.参数 元素_创建, 整数型, , Func<TKey, Elem*>
.参数 元素_是否为指定键, 整数型, , Func<Elem*, TKey, bool>
.参数 元素_销毁, 整数型, , Action<Elem*>
.局部变量 哈希表地址, 整数型

' [Offest: 0] int 数量
' [Offest: 4] Elem* 首个元素地址
' [Offest: 8] Elem* 最后元素地址
' [Offest:12] int 链表数组长度 //必须为2的幂（为了用 位于 代替 求余 加快效率）
' [Offest:16] Elem* 链表数组
' [Offest:20] Func<TKey, Elem*> 元素_创建
' [Offest:24] Func<Elem*, TKey, bool> 元素_是否为指定键
' [Offest:28] Action<Elem*> 元素_销毁

哈希表地址 = HeapAlloc (GetProcessHeap (), #HEAP_GENERATE_EXCEPTIONS, #底层哈希表_内存大小)
底层哈希表_初始化 (哈希表地址, 元素_创建, 元素_是否为指定键, 元素_销毁)
返回 (哈希表地址)
.子程序 底层哈希表_初始化, , 公开, 【不常用】
.参数 哈希表地址, 整数型
.参数 元素_创建, 整数型, , Func<TKey, Elem*>
.参数 元素_是否为指定键, 整数型, , Func<Elem*, TKey, bool>
.参数 元素_销毁, 整数型, , Action<Elem*>

memset (哈希表地址, 0, 12)
asm_写整型内存_指定偏移 (哈希表地址, 16, 12)
asm_写整型内存_指定偏移 (哈希表地址, HeapAlloc (GetProcessHeap (), 位或 (#HEAP_ZERO_MEMORY, #HEAP_GENERATE_EXCEPTIONS), 16 * 4), 16)
asm_写整型内存_指定偏移 (哈希表地址, 元素_创建, 20)
asm_写整型内存_指定偏移 (哈希表地址, 元素_是否为指定键, 24)
asm_写整型内存_指定偏移 (哈希表地址, 元素_销毁, 28)
.子程序 底层哈希表_取数量, 整数型, 公开, 返回键值对数量
.参数 哈希表地址, 整数型

' 汇编代码（需要使用AsmToECode程序编译）:
' @arg 哈希表地址
' mov eax,哈希表地址
' mov eax,[eax]
' @ret
置入代码 ({139, 69, 8, 139, 0, 201, 194, 4, 0})
返回 (0)
.子程序 底层哈希表_元素_首个, 整数型, 公开
.参数 哈希表地址, 整数型

' 汇编代码（需要使用AsmToECode程序编译）:
' @arg 哈希表地址
' mov eax,哈希表地址
' mov eax,[eax+4]
' @ret
置入代码 ({139, 69, 8, 139, 64, 4, 201, 194, 4, 0})
返回 (0)
.子程序 底层哈希表_置首个元素地址
.参数 哈希表地址, 整数型
.参数 新元素地址, 整数型

' 汇编代码（需要使用AsmToECode程序编译）:
' @arg 哈希表地址
' @arg 新元素地址
' mov eax,哈希表地址
' mov ecx,新元素地址
' mov [eax+4],ecx
' @ret
置入代码 ({139, 69, 8, 139, 77, 12, 137, 72, 4, 201, 194, 8, 0})
.子程序 底层哈希表_元素_最后, 整数型, 公开
.参数 哈希表地址, 整数型

' 汇编代码（需要使用AsmToECode程序编译）:
' @arg 哈希表地址
' mov eax,哈希表地址
' mov eax,[eax+8]
' @ret
置入代码 ({139, 69, 8, 139, 64, 8, 201, 194, 4, 0})
返回 (0)
.子程序 底层哈希表_置最后元素地址
.参数 哈希表地址, 整数型
.参数 新元素地址, 整数型

' 汇编代码（需要使用AsmToECode程序编译）:
' @arg 哈希表地址
' @arg 新元素地址
' mov eax,哈希表地址
' mov ecx,新元素地址
' mov [eax+8],ecx
' @ret
置入代码 ({139, 69, 8, 139, 77, 12, 137, 72, 8, 201, 194, 8, 0})
.子程序 底层哈希表_销毁, , 公开
.参数 哈希表地址, 整数型
.参数 回调, 子程序指针, 可空, 整数型 元素地址，整数型 额外参数
.参数 回调额外参数, 整数型, 可空
.局部变量 元素地址, 整数型
.局部变量 下一元素地址, 整数型

元素地址 = 底层哈希表_元素_首个 (哈希表地址)
.如果 (SubPtr_IsNull (回调))
    .判断循环首 (元素地址 != 0)
        下一元素地址 = 底层哈希表_元素_取下一元素 (元素地址)
        底层哈希表_元素_销毁 (哈希表地址, 元素地址)
        元素地址 = 下一元素地址
    .判断循环尾 ()
.否则
    .判断循环首 (元素地址 != 0)
        下一元素地址 = 底层哈希表_元素_取下一元素 (元素地址)
        调用销毁回调 (回调, 元素地址, 回调额外参数)
        底层哈希表_元素_销毁 (哈希表地址, 元素地址)
        元素地址 = 下一元素地址
    .判断循环尾 ()
    
.如果结束
HeapFree (GetProcessHeap (), 0, asm_读整型内存_指定偏移 (哈希表地址, 16))
HeapFree (GetProcessHeap (), 0, 哈希表地址)
.子程序 底层哈希表_需要扩容, 逻辑型
.参数 哈希表地址, 整数型

' 加载因子：0.75

' AsmToECode代码:@arg 哈希表地址
' AsmToECode代码:mov eax,哈希表地址
' AsmToECode代码:mov ecx,[eax]   ;数量
' AsmToECode代码:mov eax,[eax+12];链表数组长度
' AsmToECode代码:mov edx,eax     ;edx = eax
' AsmToECode代码:shr edx,2       ;edx /= 4
' AsmToECode代码:sub eax,edx     ;eax -= edx
' AsmToECode代码:.if ecx>eax
' AsmToECode代码:mov eax,1
' AsmToECode代码:.else
' AsmToECode代码:mov eax,0
' AsmToECode代码:.endif
' AsmToECode代码:@ret
置入代码 ({139, 69, 8, 139, 8, 139, 64, 12, 139, 208, 193, 234, 2, 43, 194, 59, 200, 118, 7, 184, 1, 0, 0, 0, 235, 5, 184, 0, 0, 0, 0, 201, 194, 4, 0})
返回 (假)
.子程序 底层哈希表_扩容
.参数 哈希表地址, 整数型
.局部变量 临时, 整数型
.局部变量 容量保存地址, 整数型
.局部变量 容量, 整数型
.局部变量 链表数组保存地址, 整数型
.局部变量 新链表数组地址, 整数型
.局部变量 元素地址, 整数型
.局部变量 当前链表当前元素地址, 整数型

容量保存地址 = asm_整数加法 (哈希表地址, 12)
容量 = asm_乘2 (asm_读整型内存 (容量保存地址))  ' 增长因子：2

链表数组保存地址 = asm_整数加法 (哈希表地址, 16)
新链表数组地址 = HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, asm_乘4 (容量))
.如果真 (新链表数组地址 == 0)
    返回 ()
.如果真结束
HeapFree (GetProcessHeap (), 0, asm_读整型内存 (链表数组保存地址))

asm_写整型内存 (容量保存地址, 容量)
asm_写整型内存 (链表数组保存地址, 新链表数组地址)

元素地址 = 底层哈希表_元素_首个 (哈希表地址)
.判断循环首 (元素地址 != 0)
    底层哈希表_元素_置当前链表下一元素 (元素地址, 0)
    
    临时 = 底层哈希表_通过哈希获取索引 (哈希表地址, 底层哈希表_元素_取哈希值 (元素地址))
    当前链表当前元素地址 = 底层哈希表_通过索引获取元素地址 (哈希表地址, 临时)
    .如果 (当前链表当前元素地址 == 0)
        底层哈希表_通过索引设置元素地址 (哈希表地址, 临时, 元素地址)
    .否则
        .循环判断首 ()
            临时 = 当前链表当前元素地址
            当前链表当前元素地址 = 底层哈希表_元素_取当前链表下一元素 (当前链表当前元素地址)
        .循环判断尾 (当前链表当前元素地址 != 0)
        底层哈希表_元素_置当前链表下一元素 (临时, 元素地址)
    .如果结束
    
    元素地址 = 底层哈希表_元素_取下一元素 (元素地址)
.判断循环尾 ()
.子程序 底层哈希表_置, 整数型, 公开
.参数 哈希表地址, 整数型
.参数 键, 整数型
.参数 键哈希值, 整数型
.参数 输出_存在, 逻辑型, 参考
.局部变量 当前链表当前元素地址, 整数型
.局部变量 当前链表上一元素地址, 整数型
.局部变量 索引, 整数型
.局部变量 新元素地址, 整数型
.局部变量 原最后元素地址, 整数型

.如果真 (底层哈希表_需要扩容 (哈希表地址))
    底层哈希表_扩容 (哈希表地址)
.如果真结束

索引 = 底层哈希表_通过哈希获取索引 (哈希表地址, 键哈希值)
当前链表当前元素地址 = 底层哈希表_通过索引获取元素地址 (哈希表地址, 索引)

.如果 (当前链表当前元素地址 != 0)
    .循环判断首 ()
        .如果真 (底层哈希表_元素_取哈希值 (当前链表当前元素地址) == 键哈希值)
            .如果真 (底层哈希表_元素_是否为指定键 (哈希表地址, 当前链表当前元素地址, 键))
                输出_存在 = 真
                返回 (当前链表当前元素地址)
            .如果真结束
            
        .如果真结束
        
        当前链表上一元素地址 = 当前链表当前元素地址
        当前链表当前元素地址 = 底层哈希表_元素_取当前链表下一元素 (当前链表当前元素地址)
    .循环判断尾 (当前链表当前元素地址 != 0)
    原最后元素地址 = 底层哈希表_元素_最后 (哈希表地址)
    新元素地址 = 底层哈希表_元素_创建 (哈希表地址, 键)
    底层哈希表_元素_初始化 (新元素地址, 键哈希值, 原最后元素地址)
    底层哈希表_元素_置当前链表下一元素 (当前链表上一元素地址, 新元素地址)
.否则
    原最后元素地址 = 底层哈希表_元素_最后 (哈希表地址)
    新元素地址 = 底层哈希表_元素_创建 (哈希表地址, 键)
    底层哈希表_元素_初始化 (新元素地址, 键哈希值, 原最后元素地址)
    底层哈希表_通过索引设置元素地址 (哈希表地址, 索引, 新元素地址)
.如果结束

.如果真 (底层哈希表_元素_首个 (哈希表地址) == 0)
    底层哈希表_置首个元素地址 (哈希表地址, 新元素地址)
.如果真结束

.如果真 (原最后元素地址 != 0)
    底层哈希表_元素_置下一元素 (原最后元素地址, 新元素地址)
.如果真结束
底层哈希表_置最后元素地址 (哈希表地址, 新元素地址)

底层哈希表_数量加1 (哈希表地址)
输出_存在 = 假
返回 (新元素地址)
.子程序 底层哈希表_取, 整数型, 公开
.参数 哈希表地址, 整数型
.参数 键, 整数型
.参数 键哈希值, 整数型
.局部变量 元素地址, 整数型
.局部变量 索引, 整数型

索引 = 底层哈希表_通过哈希获取索引 (哈希表地址, 键哈希值)
元素地址 = 底层哈希表_通过索引获取元素地址 (哈希表地址, 索引)

.判断循环首 (元素地址 != 0)
    .如果真 (底层哈希表_元素_取哈希值 (元素地址) == 键哈希值)
        .如果真 (底层哈希表_元素_是否为指定键 (哈希表地址, 元素地址, 键))
            返回 (元素地址)
        .如果真结束
        
    .如果真结束
    元素地址 = 底层哈希表_元素_取当前链表下一元素 (元素地址)
.判断循环尾 ()

返回 (0)
.子程序 底层哈希表_删, 逻辑型, 公开, 当不存在时，返回 假，否则返回 真
.参数 哈希表地址, 整数型
.参数 键, 整数型
.参数 键哈希值, 整数型
.参数 删除前处理, 子程序指针, , Action<Elem*, int>
.参数 附加参数, 整数型
.局部变量 当前链表上一元素地址, 整数型
.局部变量 当前链表下一元素地址, 整数型
.局部变量 当前链表当前元素地址, 整数型
.局部变量 上一元素, 整数型
.局部变量 下一元素, 整数型
.局部变量 索引, 整数型

索引 = 底层哈希表_通过哈希获取索引 (哈希表地址, 键哈希值)

当前链表当前元素地址 = 底层哈希表_通过索引获取元素地址 (哈希表地址, 索引)

.判断循环首 (当前链表当前元素地址 != 0)
    当前链表下一元素地址 = 底层哈希表_元素_取当前链表下一元素 (当前链表当前元素地址)
    
    .如果真 (底层哈希表_元素_取哈希值 (当前链表当前元素地址) == 键哈希值)
        .如果真 (底层哈希表_元素_是否为指定键 (哈希表地址, 当前链表当前元素地址, 键))
            .如果真 (SubPtr_IsNull (删除前处理) == 假)
                调用删除前处理回调 (删除前处理, 当前链表当前元素地址, 附加参数)
            .如果真结束
            
            
            .如果 (当前链表上一元素地址 != 0)
                底层哈希表_元素_置当前链表下一元素 (当前链表上一元素地址, 当前链表下一元素地址)
            .否则
                底层哈希表_通过索引设置元素地址 (哈希表地址, 索引, 当前链表下一元素地址)
            .如果结束
            
            上一元素 = 底层哈希表_元素_取上一元素 (当前链表当前元素地址)
            下一元素 = 底层哈希表_元素_取下一元素 (当前链表当前元素地址)
            .如果 (上一元素 != 0)
                底层哈希表_元素_置下一元素 (上一元素, 下一元素)
            .否则
                底层哈希表_置首个元素地址 (哈希表地址, 下一元素)
            .如果结束
            .如果 (下一元素 != 0)
                底层哈希表_元素_置上一元素 (下一元素, 上一元素)
            .否则
                底层哈希表_置最后元素地址 (哈希表地址, 上一元素)
            .如果结束
            
            底层哈希表_元素_销毁 (哈希表地址, 当前链表当前元素地址)
            底层哈希表_数量减1 (哈希表地址)
            返回 (真)
        .如果真结束
        
    .如果真结束
    
    当前链表上一元素地址 = 当前链表当前元素地址
    当前链表当前元素地址 = 当前链表下一元素地址
.判断循环尾 ()
返回 (假)
.子程序 底层哈希表_是否存在, 逻辑型, 公开
.参数 哈希表地址, 整数型
.参数 键, 整数型
.参数 键哈希值, 整数型
.局部变量 元素地址, 整数型
.局部变量 索引, 整数型

索引 = 底层哈希表_通过哈希获取索引 (哈希表地址, 键哈希值)
元素地址 = 底层哈希表_通过索引获取元素地址 (哈希表地址, 索引)
.判断循环首 (元素地址 != 0)
    .如果真 (底层哈希表_元素_取哈希值 (元素地址) == 键哈希值)
        .如果真 (底层哈希表_元素_是否为指定键 (哈希表地址, 元素地址, 键))
            返回 (真)
        .如果真结束
        
    .如果真结束
    元素地址 = 底层哈希表_元素_取当前链表下一元素 (元素地址)
.判断循环尾 ()
返回 (假)
.子程序 底层哈希表_数量加1
.参数 p, 整数型

' 汇编代码（需要使用AsmToECode程序编译）:
' @arg p
' mov eax,p
' inc dword ptr [eax]
' @ret
置入代码 ({139, 69, 8, 255, 0, 201, 194, 4, 0})
.子程序 底层哈希表_数量减1
.参数 p, 整数型

' 汇编代码（需要使用AsmToECode程序编译）:
' @arg p
' mov eax,p
' dec dword ptr [eax]
' @ret
置入代码 ({139, 69, 8, 255, 8, 201, 194, 4, 0})
.子程序 底层哈希表_通过哈希获取索引, 整数型
.参数 hashmap, 整数型
.参数 hash, 整数型

' AsmToECode代码:@arg hashmap
' AsmToECode代码:@arg hash
' AsmToECode代码:; eax = (hash ^ (hash>>>16)) & (链表数组长度-1)
' AsmToECode代码:mov eax,hash
' AsmToECode代码:mov edx,hashmap
' AsmToECode代码:mov ecx,eax
' AsmToECode代码:mov edx,[edx+12] ;链表数组长度
' AsmToECode代码:shr ecx,16
' AsmToECode代码:add edx,-1
' AsmToECode代码:xor eax,ecx
' AsmToECode代码:and eax,edx
' AsmToECode代码:@ret
置入代码 ({139, 69, 12, 139, 85, 8, 139, 200, 139, 82, 12, 193, 233, 16, 131, 194, 255, 51, 193, 35, 194, 201, 194, 8, 0})
返回 (0)  ' 已在汇编中做返回操作
.子程序 底层哈希表_通过索引获取元素地址, 整数型
.参数 哈希表地址, 整数型
.参数 索引, 整数型, , 从0开始

' 汇编代码（需要使用AsmToECode程序编译）:
' @arg 哈希表地址
' @arg 索引
' mov eax,哈希表地址
' mov eax,[eax+16]
' mov ecx,索引
' mov eax,[eax+ecx*4]
' @ret
置入代码 ({139, 69, 8, 139, 64, 16, 139, 77, 12, 139, 4, 136, 201, 194, 8, 0})
返回 (0)
.子程序 底层哈希表_通过索引设置元素地址, 整数型
.参数 哈希表地址, 整数型
.参数 索引, 整数型, , 从0开始
.参数 新值, 整数型

' 汇编代码（需要使用AsmToECode程序编译）:
' @arg 哈希表地址
' @arg 索引
' @arg 新值
' mov eax,哈希表地址
' mov eax,[eax+16]
' mov ecx,索引
' mov edx,新值
' mov [eax+ecx*4],edx
' @ret
置入代码 ({139, 69, 8, 139, 64, 16, 139, 77, 12, 139, 85, 16, 137, 20, 136, 201, 194, 12, 0})
返回 (0)
.子程序 底层哈希表_元素_创建, 整数型
.参数 哈希表地址, 整数型
.参数 键, 整数型

' ----------------------
' int 哈希值
' int 当前链表下一元素
' int 上一元素
' int 下一元素
' ----------------------

' AsmToECode代码:leave
' AsmToECode代码:pop edx;ReturnAddress
' AsmToECode代码:pop eax;HashMapPtr
' AsmToECode代码:push edx
' AsmToECode代码:mov eax,[eax+20]
' AsmToECode代码:jmp eax
置入代码 ({201, 90, 88, 82, 139, 64, 20, 255, 224})
返回 (0)
.子程序 底层哈希表_元素_是否为指定键, 逻辑型
.参数 哈希表地址, 整数型
.参数 元素地址, 整数型
.参数 键, 整数型

' AsmToECode代码:leave
' AsmToECode代码:pop edx;ReturnAddress
' AsmToECode代码:pop eax;HashMapPtr
' AsmToECode代码:push edx
' AsmToECode代码:mov eax,[eax+24]
' AsmToECode代码:jmp eax
置入代码 ({201, 90, 88, 82, 139, 64, 24, 255, 224})
返回 (假)
.子程序 底层哈希表_元素_销毁, , , 调用前请先处理 当前链表下一元素、上一元素、下一元素 等成员
.参数 哈希表地址, 整数型
.参数 元素地址, 整数型

' AsmToECode代码:leave
' AsmToECode代码:pop edx;ReturnAddress
' AsmToECode代码:pop eax;HashMapPtr
' AsmToECode代码:push edx
' AsmToECode代码:mov eax,[eax+28]
' AsmToECode代码:jmp eax
置入代码 ({201, 90, 88, 82, 139, 64, 28, 255, 224})
.子程序 底层哈希表_元素_置上一元素
.参数 ptr, 整数型
.参数 新上一元素, 整数型

' 汇编代码（需要使用AsmToECode程序编译）:
' @arg pn
' @arg 新上一元素
' mov ecx,新上一元素
' mov eax,pn
' mov [eax+8],ecx
' @ret
置入代码 ({139, 77, 12, 139, 69, 8, 137, 72, 8, 201, 194, 8, 0})
.子程序 底层哈希表_元素_取上一元素, 整数型, 公开
.参数 ptr, 整数型

' 汇编代码（需要使用AsmToECode程序编译）:
' @arg pn
' mov eax,pn
' mov eax,[eax+8]
' @ret
置入代码 ({139, 69, 8, 139, 64, 8, 201, 194, 4, 0})
返回 (0)
.子程序 底层哈希表_元素_置下一元素
.参数 ptr, 整数型
.参数 新下一元素, 整数型

' 汇编代码（需要使用AsmToECode程序编译）:
' @arg pn
' @arg 新下一元素
' mov ecx,新下一元素
' mov eax,pn
' mov [eax+12],ecx
' @ret
置入代码 ({139, 77, 12, 139, 69, 8, 137, 72, 12, 201, 194, 8, 0})
.子程序 底层哈希表_元素_取下一元素, 整数型, 公开
.参数 ptr, 整数型

' 汇编代码（需要使用AsmToECode程序编译）:
' @arg pn
' mov eax,pn
' mov eax,[eax+12]
' @ret
置入代码 ({139, 69, 8, 139, 64, 12, 201, 194, 4, 0})
返回 (0)
.子程序 底层哈希表_元素_置当前链表下一元素
.参数 ptr, 整数型
.参数 下一元素, 整数型

' 汇编代码（需要使用AsmToECode程序编译）:
' @arg pn
' @arg 下一元素
' mov eax,pn
' mov ecx,下一元素
' mov dword ptr [eax+4],ecx
置入代码 ({139, 69, 8, 139, 77, 12, 137, 72, 4})
.子程序 底层哈希表_元素_取当前链表下一元素, 整数型
.参数 ptr, 整数型

' 汇编代码（需要使用AsmToECode程序编译）:
' @arg pn
' mov eax,pn
' mov eax,[eax+4]
' @ret
置入代码 ({139, 69, 8, 139, 64, 4, 201, 194, 4, 0})
返回 (0)
.子程序 底层哈希表_元素_取哈希值, 整数型, 公开
.参数 ptr, 整数型

' 汇编代码（需要使用AsmToECode程序编译）:
' @arg pn
' mov eax,pn
' mov eax,[eax]
' @ret
置入代码 ({139, 69, 8, 139, 0, 201, 194, 4, 0})
返回 (0)
.子程序 底层哈希表_元素_初始化
.参数 ptr, 整数型
.参数 哈希值, 整数型
.参数 上一元素, 整数型

' AsmToECode代码:@arg pn
' AsmToECode代码:@arg 哈希值
' AsmToECode代码:@arg 上一元素
' AsmToECode代码:mov eax,pn
' AsmToECode代码:mov ecx,哈希值
' AsmToECode代码:mov dword ptr [eax],ecx
' AsmToECode代码:mov edx,上一元素
' AsmToECode代码:mov dword ptr [eax+8],edx
' AsmToECode代码:mov dword ptr [eax+4],0
' AsmToECode代码:mov dword ptr [eax+12],0
置入代码 ({139, 69, 8, 139, 77, 12, 137, 8, 139, 85, 16, 137, 80, 8, 199, 64, 4, 0, 0, 0, 0, 199, 64, 12, 0, 0, 0, 0})
